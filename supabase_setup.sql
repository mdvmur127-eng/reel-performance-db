-- Run this in Supabase SQL Editor for project: lhmbqwasymbkqnnqnjxr

create table if not exists public.reels (
  id bigint generated by default as identity primary key,
  created_at timestamptz not null default now(),
  published_at timestamptz,
  user_id uuid not null default auth.uid(),
  title text not null,
  platform text not null,
  storage_path text not null,
  video_url text,
  reel_type text not null default 'video',
  views integer not null default 0,
  likes integer not null default 0,
  comments integer not null default 0,
  saves integer not null default 0,
  avg_watch_time numeric,
  average_watch_time numeric,
  this_reel_skip_rate numeric,
  accounts_reached integer
);

alter table public.reels
  add column if not exists created_at timestamptz not null default now(),
  add column if not exists published_at timestamptz,
  add column if not exists user_id uuid,
  add column if not exists title text,
  add column if not exists platform text,
  add column if not exists storage_path text,
  add column if not exists video_url text,
  add column if not exists reel_type text not null default 'video',
  add column if not exists views integer not null default 0,
  add column if not exists likes integer not null default 0,
  add column if not exists comments integer not null default 0,
  add column if not exists saves integer not null default 0,
  add column if not exists avg_watch_time numeric,
  add column if not exists average_watch_time numeric,
  add column if not exists this_reel_skip_rate numeric,
  add column if not exists accounts_reached integer;

alter table public.reels
  drop column if exists hold_rate_3s;

do $$
begin
  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public' and table_name = 'reels' and column_name = 'name'
  ) then
    update public.reels
    set title = coalesce(title, name)
    where title is null;
  end if;

  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public' and table_name = 'reels' and column_name = 'avg_watch_time'
  ) then
    update public.reels
    set average_watch_time = coalesce(average_watch_time, avg_watch_time)
    where average_watch_time is null;

    update public.reels
    set avg_watch_time = round((avg_watch_time / 1000.0)::numeric, 2)
    where avg_watch_time > 600;
  end if;

  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public' and table_name = 'reels' and column_name = 'average_watch_time'
  ) then
    update public.reels
    set average_watch_time = round((average_watch_time / 1000.0)::numeric, 2)
    where average_watch_time > 600;
  end if;

  if exists (
    select 1
    from information_schema.columns
    where table_schema = 'public' and table_name = 'reels' and column_name = 'published_at'
  ) then
    update public.reels
    set published_at = created_at
    where published_at is null;
  end if;

end $$;

create table if not exists public.instagram_oauth_states (
  state text primary key,
  user_id uuid not null references auth.users(id) on delete cascade,
  created_at timestamptz not null default now(),
  expires_at timestamptz not null
);

create table if not exists public.instagram_connections (
  user_id uuid primary key references auth.users(id) on delete cascade,
  access_token text not null,
  token_type text,
  expires_at timestamptz,
  created_at timestamptz not null default now(),
  updated_at timestamptz not null default now()
);

alter table public.instagram_oauth_states enable row level security;
alter table public.instagram_connections enable row level security;

drop policy if exists "No direct access to oauth states" on public.instagram_oauth_states;
drop policy if exists "No direct access to instagram connections" on public.instagram_connections;

create policy "No direct access to oauth states"
on public.instagram_oauth_states
for all
to authenticated
using (false)
with check (false);

create policy "No direct access to instagram connections"
on public.instagram_connections
for all
to authenticated
using (false)
with check (false);

alter table public.reels enable row level security;

drop policy if exists "public read reels" on public.reels;
drop policy if exists "public insert reels" on public.reels;
drop policy if exists "public update reels" on public.reels;
drop policy if exists "public delete reels" on public.reels;
drop policy if exists "Users can select their own reels" on public.reels;
drop policy if exists "Users can insert their own reels" on public.reels;
drop policy if exists "Users can update their own reels" on public.reels;
drop policy if exists "Users can delete their own reels" on public.reels;

create policy "Users can select their own reels"
on public.reels
for select
to authenticated
using (auth.uid() = user_id);

create policy "Users can insert their own reels"
on public.reels
for insert
to authenticated
with check (auth.uid() = user_id);

create policy "Users can update their own reels"
on public.reels
for update
to authenticated
using (auth.uid() = user_id)
with check (auth.uid() = user_id);

create policy "Users can delete their own reels"
on public.reels
for delete
to authenticated
using (auth.uid() = user_id);

insert into storage.buckets (id, name, public)
values ('reels', 'reels', false)
on conflict (id) do nothing;

drop policy if exists "public read reel files" on storage.objects;
drop policy if exists "Users can read their own reel files" on storage.objects;
create policy "public read reel files"
on storage.objects
for select
to authenticated
using (
  bucket_id = 'reels'
  and (storage.foldername(name))[1] = auth.uid()::text
);

drop policy if exists "public upload reel files" on storage.objects;
drop policy if exists "Users can upload their own reel files" on storage.objects;
create policy "public upload reel files"
on storage.objects
for insert
to authenticated
with check (
  bucket_id = 'reels'
  and (storage.foldername(name))[1] = auth.uid()::text
);

drop policy if exists "public delete reel files" on storage.objects;
drop policy if exists "Users can delete their own reel files" on storage.objects;
create policy "public delete reel files"
on storage.objects
for delete
to authenticated
using (
  bucket_id = 'reels'
  and (storage.foldername(name))[1] = auth.uid()::text
);
